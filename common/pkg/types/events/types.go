package events

import (
	"crypto/sha256"
	"encoding/xml"
	"github.com/RyanW02/wineventchain/common/pkg/types/identity"
	"github.com/google/uuid"
	"go.mongodb.org/mongo-driver/bson"
	"time"
)

type (
	EventWithMetadata struct {
		ScrubbedEvent
		Metadata Metadata `json:"metadata" xml:"-"`
	}

	// Metadata contains information *generated by the blockchain node* about the event.
	Metadata struct {
		// EventId is the unique identifier of the event. It is based off of a SHA-256 hash of the block height the
		// event was received at, and the event metadata (System, contained within an Event struct).
		EventId EventHash `json:"event_id" bson:"event_id"`
		// ReceivedTime is the time when the event was received by the blockchain node.
		ReceivedTime time.Time `json:"received_time" bson:"received_time"`
		// Principal is the identity of the entity that generated the event.
		Principal identity.Principal `json:"principal" bson:"principal"`
	}

	Event struct {
		System System `json:"system" bson:"system" xml:"System"`
	}

	EventWithData struct {
		Event
		EventData EventData `json:"event_data" bson:"event_data" xml:"EventData>Data"`
	}

	ScrubbedEvent struct {
		OffChainHash string `json:"offchain_hash"`
		Event        Event  `json:"event"`
	}

	StoredEvent struct {
		EventWithData EventWithData `json:"event" bson:"event"`
		Metadata      Metadata      `json:"metadata" bson:"metadata"`
		TxHash        TxHash        `json:"tx_hash" bson:"tx_hash"`
	}

	// EventId is the event type ID - it represents the type of the event, e.g. system log on
	EventId int

	System struct {
		Provider Provider `json:"provider" bson:"provider" xml:"Provider"`
		// EventId is the event type ID - it represents the type of the event, e.g. system log on
		EventId EventId `json:"event_id" bson:"event_id" xml:"EventID"`
		// TimeCreated contains timestamps associated to the creation of the event.
		TimeCreated TimeCreated `json:"time_created" bson:"time_created" xml:"TimeCreated"`
		// EventRecordId is the local ID assigned to a record on the computer it was generated
		EventRecordId int `json:"event_record_id" bson:"event_record_id" xml:"EventRecordID"`
		// Correlation contains information that can be used to correlate multiple related events.
		Correlation Correlation `json:"correlation" bson:"correlation" xml:"Correlation"`
		// Execution contains information about the process that generated the event.
		Execution Execution `json:"execution" bson:"execution" xml:"Execution"`
		// Channel is the name of the event log channel that the event was generated from, e.g. Security, System, etc.
		Channel string `json:"channel" bson:"channel" xml:"Channel"`
		// Computer is the hostname of the computer that generated the event. However, this may be manipulated as it can
		// be arbitrarily set and signed by the event creator. Instead, the principal should be used to verify the
		// identity of the computer that generated the event.
		Computer string `json:"computer" bson:"computer" xml:"Computer"`
	}

	// Provider contains information about the event source that generated the event.
	Provider struct {
		// Name is the name of the event source that generated the event.
		Name *string `json:"name" bson:"name" xml:"Name,attr"`
		// Guid is the globally unique identifier of the event source. It is a string of the form {UUID}.
		Guid *Guid `json:"guid" bson:"guid" xml:"Guid,attr"`
		// EventSourceName is an alternative name of the event source that generated the event.
		EventSourceName *string `json:"event_source_name" bson:"event_source_name" xml:"EventSourceName,attr"`
	}

	// TimeCreated contains timestamps associated to the creation of the event.
	TimeCreated struct {
		// SystemTime is the local time of the computer that generated the event, at the timestamp the event was
		// generated locally.
		SystemTime time.Time `json:"system_time" bson:"system_time" xml:"SystemTime,attr"`
	}

	// Correlation contains information that can be used to correlate multiple related events.
	Correlation struct {
		// ActivityId is assigned to multiple events that are part of the same activity that can be used to correlate
		// multiple related events. It is a string of the form {UUID}.
		ActivityId *Guid `json:"activity_id" bson:"activity_id" xml:"ActivityID,attr"`
	}

	// Execution contains information about the process that generated the event.
	Execution struct {
		// ProcessId is the numeric ID of the process that generated the event.
		ProcessId *int `json:"process_id" bson:"process_id" xml:"ProcessID,attr"`
		// ThreadId is the numeric ID of the OS thread that the event was generated on.
		ThreadId *int `json:"thread_id" bson:"thread_id" xml:"ThreadID,attr"`
	}

	// EventData is a collection of key-value pairs that store data associated with the event.
	// Must be stored and rendered as an ordered array rather than a JSON object to maintain order
	// for deterministic hashing.
	EventData []Data

	// Data is a key-value pair that stores a piece of data associated to the event.
	Data struct {
		Name  *string `json:"name" bson:"name" xml:"Name,attr"`
		Value *string `json:"value" bson:"value" xml:",innerxml"`
	}
)

// Hash returns the SHA-256 hash of the event data.
func (d EventData) Hash() []byte {
	h := sha256.New()
	for _, data := range d {
		if data.Name != nil {
			h.Write([]byte(*data.Name))
		}

		if data.Value != nil {
			h.Write([]byte(*data.Value))
		}
	}

	return h.Sum(nil)
}

// UnmarshalXML can't unmarshal to a string pointer with ,innerxml - we must provider a custom unmarshaler to work around this
func (d *Data) UnmarshalXML(decoder *xml.Decoder, start xml.StartElement) error {
	var data struct {
		Name  string `json:"name" bson:"name" xml:"Name,attr"`
		Value string `json:"value" bson:"value" xml:",innerxml"`
	}

	if err := decoder.DecodeElement(&data, &start); err != nil {
		return err
	}

	if data.Name != "" {
		d.Name = &data.Name
	}

	if data.Value != "" {
		d.Value = &data.Value
	}

	return nil
}

// UnmarshalBSON is implemented to unmarshal null UUIDs into nil, rather than UUID.Zero(), which is the default behavior
// of MongoDB's BSON unmarshaler.
func (p *Provider) UnmarshalBSON(bytes []byte) error {
	type Alias Provider
	var aux Alias
	if err := bson.Unmarshal(bytes, &aux); err != nil {
		return err
	}

	if aux.Name != nil && *aux.Name != "" {
		p.Name = aux.Name
	}

	if aux.Guid != nil && aux.Guid.UUID() != uuid.Nil {
		p.Guid = aux.Guid
	}

	if aux.EventSourceName != nil && *aux.EventSourceName != "" {
		p.EventSourceName = aux.EventSourceName
	}

	return nil
}

// UnmarshalBSON is implemented to unmarshal null UUIDs into nil, rather than UUID.Zero(), which is the default behavior
// of MongoDB's BSON unmarshaler.
func (c *Correlation) UnmarshalBSON(bytes []byte) error {
	type Alias Correlation
	var aux Alias
	if err := bson.Unmarshal(bytes, &aux); err != nil {
		return err
	}

	if aux.ActivityId != nil && aux.ActivityId.UUID() != uuid.Nil {
		c.ActivityId = aux.ActivityId
	}

	return nil
}
