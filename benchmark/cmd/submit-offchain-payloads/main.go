package main

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"flag"
	"fmt"
	types "github.com/RyanW02/wineventchain/common/pkg/types/offchain"
	"go.uber.org/atomic"
	"golang.org/x/sync/errgroup"
	"net/http"
	"net/url"
	"os"
	"time"
)

var (
	uriRaw   = flag.String("uri", "http://localhost:8080", "Off-chain node URI")
	workers  = flag.Int("workers", 100, "Number of workers to use for submitting events")
	file     = flag.String("payloads_file", "out.json", "Payloads file, as generated by store-ang-generate-offchain-payloads")
	duration = flag.Int("time", 10, "Time in seconds to run the load test for")
)

func main() {
	flag.Parse()

	// Read events
	data, err := os.ReadFile(*file)
	if err != nil {
		panic(err)
	}

	var payloads []types.SubmitRequest
	if err := json.Unmarshal(data, &payloads); err != nil {
		panic(err)
	}

	ch := make(chan []byte, len(payloads))
	for _, payload := range payloads {
		data, err := json.Marshal(payload)
		if err != nil {
			panic(err)
		}
		ch <- data
	}
	close(ch)

	// Setup HTTP client
	if *uriRaw == "" {
		flag.Usage()
		os.Exit(1)
	}

	uri, err := url.Parse(*uriRaw)
	if err != nil {
		panic(err)
	}

	uri.Path = "/event"
	uriStr := uri.String()

	client := &http.Client{}

	fmt.Printf(
		"Starting load test with using %d workers. Events loaded: %d. Timeout: %ds\n",
		*workers, len(payloads), *duration,
	)

	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(*duration)*time.Second)
	defer cancel()

	start := time.Now()

	group, _ := errgroup.WithContext(ctx)
	count := atomic.NewInt32(0)
	for i := 0; i < *workers; i++ {
		group.Go(func() error {
			for data := range ch {
				req, err := http.NewRequestWithContext(ctx, http.MethodPost, uriStr, bytes.NewBuffer(data))
				if err != nil {
					return err
				}

				resp, err := client.Do(req)
				if err != nil {
					return err
				}

				if resp.StatusCode != http.StatusCreated {
					return fmt.Errorf("unexpected status code: %d", resp.StatusCode)
				}

				count.Inc()
			}

			return nil
		})
	}

	if err := group.Wait(); err != nil {
		if !errors.Is(err, context.DeadlineExceeded) {
			panic(err)
		}
	}

	deadline, _ := ctx.Deadline()
	elapsed := deadline.Sub(start)

	rps := float64(count.Load()) / float64(elapsed.Milliseconds()) * 1000
	fmt.Printf("Stored %d events in %d ms (%.2f rps)\n", count.Load(), elapsed.Milliseconds(), rps)
}
